---
layout: post
title: 2. Essential concept(Reference, Pointer to structure, Functions)
category: Algorithm
tag: Algorithm
---

# Reference

```c++
int main()
{
  int a = 10;
  int &r = a;
}
```

<a href="https://postimg.cc/hQvCk5gr"><img src="https://i.postimg.cc/C5HWf3QW/Capture.jpg" width="500px" title="source: imgur.com" /><a>

- 레퍼런스 r은 stack에 카피되지 않고 a의 벨류를 받아쓴다. 즉 a = r이 된다.
  - Move 개념이다. 단 a=r는 똑같은 address 주소로 같은 밸류를 갖고 있다.
- 포인터는 오직 data type에 따른 메모리만 할당 된다. (bytes)
```c++
int main()
{
  int a = 10;
  int &r = a;
  cout<<a; //10;
  r++;
  cout<<r; //11;
  cout<<a; //11;
}
```

# pointer to structure

<a href="https://postimg.cc/hQvCk5gr"><img src="https://i.postimg.cc/C5HWf3QW/Capture.jpg" width="500px" title="source: imgur.com" /><a>

```c++
struct Rectangle
{
  int length; // 4bytes
  int height; // 4 bytes
}; // 8bytes
int main()
{
  struct Rectangle r={10,5};
  struct Rectangle* p = &r;

  r = length.15;
  p->length = 20;
  cout>>r.length<<endl; //20;
}
```
- when we create a pointer which is pointing to memory allocation of structure or class, we use "->" to pointing a data variable inside structure or class when we using a pointer.
- 포인팅하는 어드레스에다가 포인터에게 값을 넣어주면 그 address에있는 밸류값이 포인터에게 주어진 값으로 바뀐다.

- Modern C++(C++11부터)는 Smart pointer를 쓰인다, 왜냐하면 메모리 릭등 항상 dereferecing을 하기 귀찮고, 잘못되면 프로그램에 문제가 생기기 떄문이다.
  - #include <memory>
    - std::unique_ptr<>
      - 보통 Raw pointer로 많이 쓰인다.
    - std::share_ptr<>
      - 여러 포인터가 address를 공유할 수 있도록 한다.

# Functions
- Parameter passing
  - pass by value
  - pass by Address
  - pass by reference.

## Case 1(monolithic program)
  ```c++
  int main()
  {
    ---------------------
    ---------------------
    ---------------------
    ---------------------
    ---------------------
    ---------------------
    ---------------------
    ---------------------
    ---------------------
    ---------------------
    ---------------------
  }
  ```

## Case 2 ( Modular Program, Procedeure program)
```c++
void func1()
{
  ---------------------
}
int func2()
{
  ---------------------
}
float func3()
{
  ---------------------
}
void func4()
{
  ---------------------
}
int main()
{
  fun1();
  fun2();
  fun3();
  fun4();
}
```

```c++
int add(int a, int b)
{
  int c;
  c= a+b;
  return(c);
}
int main()
{
  int x,y,z;
  x= 10;
  y= 5;
  z = add(x,y);
  cout<<z;
}
```
- int add는 proto type(즉 리턴값을 어떤 데이터 유형을 쓸것인지)
- int a, int b는 Funtion parameter
- add(x,y)는 Actual Parameter

<a href="https://postimg.cc/d7JBCV3X"><img src="https://i.postimg.cc/0NwHL6s8/Capture.jpg" width="500px" title="source: imgur.com" /><a>

```c++
int add(int* a, int* b)
{
  int c;
  c= a+b;
  return(c);
}
int main()
{
  int x,y,z;
  x= 10;
  y= 5;
  z = add(&x,&y);
  cout<<z;
}
```

<a href="https://postimg.cc/Xp8XJNMX"><img src="https://i.postimg.cc/9Q39LzJP/Capture.jpg" width="500px" title="source: imgur.com" /><a>
