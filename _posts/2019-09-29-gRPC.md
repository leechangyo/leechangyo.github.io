---
layout: post
title: gRPC란 무엇인가
category: Programming
tag: 통신
---

# gRPC
- Robot을 연구하다 보면 리눅스 체제의 컴퓨터와 하드웨어 연결하는데 있어 gRPC라는 이용하는 곳을 본적이 있을 것입니다.
- gRPC는 구글이 최초로 개발한 오픈 소스 원격 프로시저 호출 (RPC) 시스템이다.
- **HTTP 기반 원격 함수 호출을 해주는 즉, RPC(Remote Procedure Call) 프레임워크라고 할 수 있습니다.**
- RPC는 네트워크 상 원격에 있는 서버의 서비스를 호출하는데 사용되는 프로토콜로 IDL(Interface Definition Language)로 인터페이스를 정의한 후 이에 해당하는 Skeleton 과 Stub 코드를 통해 프로그래밍 언어에서 호출해서 사용하는 방식이라고 보면 됩니다.
- 최근에는 HTTP를 활용한 SOAP, RESTful 등이 많이 활용되어서 RPC는 거의 사용이 되지 않으나 요청/응답을 위한 규약이 명시적이지 않다는 단점으로 인해 다시 RPC의 방식을 채용한 프렘임워크들이 나오기 시작했습니다
- gRPC는 자바,C/C++ 뿐만 아니라 Node.js, Python, Ruby, PHP, Go, Android 기반, Objective-C 등 다양한 언어들을 지원함으로 서버간 뿐만이 아니라 클라이언트 어플리케이션이나 모바일 앱에서도 사용가능한 RPC 프레임워크입니다.

## 1. 사전 준비 사항
- golang 기반으로 gRPC를 테스트하려면 당연히 golang이 설치되어야 합니다. 그리고 gRPC는 함수 호출간 직렬화된 데이터를 주고 받는데 구조화된 객체를 직렬화하기 위해서 Protocol Buffers 를 사용하고 있으므로 함께 설치하여 줍니다.

### 1.1 Golang 설치
- 다음의 사이트를 참조하여 golang 바이너리를 설치합니다. (이 문서에서는 Linux/MacOS 기반으로 설명합니다.)
  - [Golang 바이너리 다운로드](https://golang.org/doc/install?cm_mc_uid=02652595810614900694309&cm_mc_sid_50200000=1490500863)
- 다운로드 받은 압축파일을 다음의 명령어를 통해 설치합니다.
```
tar -C /usr/local -xzf <다운로드 받은 압축파일>
```
- 압축을 푼 후 적절한 위치에 go 소스가 위치할 디렉토리를 생성한 후 $HOME/.profile에 다음의 환경변수를 설정합니다.
```
$HOME 아래에 work라는 디렉토리 생성

mkdir $HOME/work
export GOROOT=/usr/local/go
export GOPATH=$HOME/work
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
```
- 여기까지 설치를 완료하였으면 다음의 코드를 통해 정상동작 테스트합니다. 먼저 다음의 디렉토리를 생성합니다.
```
mkdir -p $GOPATH/src/hello
```
- 그리곤 hello.go 파일명으로 다음의 코드를 생성합니다.
```
package main

import "fmt"

func main() {
    fmt.Printf("hello, world\n")
}
```
- 소스코드를 생성하였으면 빌드합니다.
```
cd $GOPATH/src/hello
go build
```
- 컴파일이 정상적으로 완료된 후 다음의 명령을 통해서 실행하여 결과를 확인합니다.
```
./hello
hello, world
```
### 1.2 gRPC 설치
- 다음의 명령을 통해서 gRPC를 설치합니다.
```
go get google.golang.org/grpc
```
### 1.3  Protocol Buffers 설치
- 다음의 경로에서 Protocol Buffers 압축파일을 받습니다. https://github.com/google/protobuf/releases – 다운받아야 할 압축파일명은 protoc-<버전>–<플랫폼>.zip 파일입니다.
- 다운받은 압축파일은 적당한 위치에 풀어서 해당하는 위치를 PATH에 추가합니다. 다음은 저의 설정 예입니다
<a href="https://postimg.cc/ZCFvHcF7"><img src="https://i.postimg.cc/YqTNpD4H/213223.png" width="700px" title="source: imgur.com" /></a>
- 다음으로 Golang 기반의 protoc 플러그인을 설치합니다.
```
go get -u github.com/golang/protobuf/{proto,protoc-gen-go}
```

## 2. 샘플을 통해 이해하기
- 1.2 항목에서 gRPC 를 설치하였으면 그 하위 디렉토리에 examples 들이 존재합니다. 그 중 helloworld를 통해서 알아보겠습니다.
그 위치는 아래와 같습니다.
```
cd $GOPATH/src/google.golang.org/grpc/helloworld
```
- 위의 디렉토리 하위에는 greeter_client, greeter_server, helloworld 의 세 디렉토리가 보입니다.
- 그 중 helloworld 하위엔 .proto 파일이 존재하며 이 파일이 gRPC 서비스가 명시되는 곳입니다.
- 여기에 존재하는 파일을 기준으로 protoc 명령을 통해 .pb.go 파일이 생성되며 이 파일은 클라이언트와 서버 코드와 함수 호출시 주고받을 메세지 타입이 생성됩니다.
- 서버 코드를 빌드하고 실행합니다. 위치는 “$GOPATH/src/google.golang.org/grpc/helloworld” 에서 실행합니다
```
go run greeter_server/main.go
```
- 그리고 터미널을 하나 더 열어서 다음의 명령으로 클라이언트를 실행합니다.
```
go run greeter_client/main.go
```
- 실행결과 “Greeting: Hello world” 메시지가 나오면 정상 실행된 것입니다.

## 3. gRPC 서비스 업데이트
- 앞서 실행한 명령은 SayHello라는 함수를 클라이언트가 호출하면 서버에서 메세지를 받아서 클라이언트가 출력하는 내용이었습니다.
- 여기에 SayHelloAgain이라는 함수를 추가하도록 하겠습니다.
- 다음과 같이 .proto 파일을 업데이트합니다
```
helloworld.proto 파일의 위치

$GOPATH/src/google.golang.org/grpc/examples/helloworld/helloworld/helloworld.proto
```
```
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
```
- 다음으로 gRPC 코드를 생성합니다.
```
protoc -I helloworld/ helloworld/helloworld.proto --go_out=plugins=grpc:helloworld
```
- 서버 및 클라이언트 코드를 수정한 후 실행하여 수정된 내용이 반영되었는지 확인합니다.
- 서버코드 업데이트 – greeter_server/main.go
```
func (s *server) SayHelloAgain(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
    return &pb.HelloReply{Message: "Hello again " + in.Name}, nil
}
```
- 클라이언트 업데이트 – greeter_client/main.go
```
r, err = c.SayHelloAgain(context.Background(), &pb.HelloRequest{Name: name})
if err != nil {
    log.Fatalf("could not greet: %v", err)
}
log.Printf("Greeting: %s", r.Message)
```
- 코드 수정되었으면 실행하여 동작을 확인합니다.
- 서버 실행
```
go run greeter_server/main.go
```
- 클라이언트 실행
```
go run greeter_client/main.go
```
- 다음과 같이 실행결과를 확인합니다.
<a href="https://postimg.cc/s10h1c9b"><img src="https://i.postimg.cc/L6mBCQq4/55231.png" width="700px" title="source: imgur.com" /></a>

# Reference

[IBM DEVELOPER](https://developer.ibm.com/kr/cloud/blockchain/2017/03/26/grpc_overview_01/)
