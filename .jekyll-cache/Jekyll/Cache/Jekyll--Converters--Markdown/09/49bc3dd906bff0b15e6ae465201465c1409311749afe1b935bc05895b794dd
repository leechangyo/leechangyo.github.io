I"<h1 id="list"><a href="https://modoocode.com/223#page-heading-6">List</a></h1>
<ul>
  <li>리스트(list) 의 경우 양방향 연결 구조를 가진 자료형이라 볼 수 있습니다.
<a href="https://postimg.cc/hJhw6RbC"><img src="https://i.postimg.cc/VNF8SYSc/42131232.png" width="700px" title="source: imgur.com" /></a></li>
  <li>따라서 vector 와는 달리 임의의 위치에 있는 원소에 접근을 바로 할 수 없습니다.</li>
  <li>list 컨테이너 자체에서는 시작 원소와 마지막 원소의 위치만을 기억하기 때문에, 임의의 위치에 있는 원소에 접근하기 위해서는 하나씩 링크를 따라가야 합니다.</li>
  <li>그래서 리스트에는 아예 [] 나 at 함수가 아예 정의되어 있지 않습니다.</li>
  <li>vector 의 경우 맨 뒤를 제외하고는 임의의 위치에 원소를 추가하거나 제거하는 작업이 O(n)O(n) 이였지만 리스트의 경우 O(1)O(1) 으로 매우 빠르게 수행될 수 있습니다.</li>
  <li>왜냐하면 원하는 위치 앞과 뒤에 있는 링크값만 바꿔주면 되기 때문입니다.</li>
</ul>

<blockquote>
  <p>예제
```
#include <iostream>
#include <list></list></iostream></p>
</blockquote>

<p>int main() {
  std::list<int> lst;</int></p>

<p>lst.push_back(10);
  lst.push_back(20);
  lst.push_back(30);
  lst.push_back(40);</p>

<p>for (std::list<int>::iterator itr = lst.begin(); itr != lst.end(); ++itr) {
    std::cout &lt;&lt; *itr &lt;&lt; std::endl;
  }
}</int></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&gt; 결과

</code></pre></div></div>
<p>10
20
30
40</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 주의할 점은 리스트의 반복자의 경우 다음과 같은 연산 밖에 수행 할 수 없습니다.
</code></pre></div></div>
<p>itr++    // itr ++
itr–  // –itr 도 됩니다.</p>

<p>itr + 5 //불가능</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 임의의 위치에 있는 원소를 가리킬 수 없다는 것입니다.
- 반복자는 오직 한 칸 씩 밖에 움직일 수 없습니다.
- 즉, 메모리 상에서 원소들이 연속적으로 존재하지 않을 수 있다는 뜻입니다.
- 반면에 벡터의 경우 메모리 상에서 연속적으로 존재하기 때문에 쉽게 임의의 위치에 있는 원소를 참조할 수 있습니다.
-  erase 함수를 이용하여 원하는 위치에 있는 원소를 지울 수 도 있습니다.
- 리스트의 경우는 벡터와는 다르게, 원소를 지워도 반복자가 무효화 되지 않습니다.
- 왜냐하면, 각 원소들의 주소값들은 바뀌지 않기 때문입니다.

## Example
- 1번째 배열에 100이 추가가 된다.
</code></pre></div></div>
<p>#include <iostream>
#include <list></list></iostream></p>

<p>template <typename T="">
void print_list(std::list<T>&amp; lst) {
  std::cout &lt;&lt; "[ ";
  // 전체 리스트를 출력하기 (이 역시 범위 기반 for 문을 쓸 수 있습니다)
  for (const auto&amp; elem : lst) {
    std::cout &lt;&lt; elem &lt;&lt; " ";
  }
  std::cout &lt;&lt; "]" &lt;&lt; std::endl;
}
int main() {
  std::list<int> lst;</int></T></typename></p>

<p>lst.push_back(10);
  lst.push_back(20);
  lst.push_back(30);
  lst.push_back(40);</p>

<p>std::cout « “처음 리스트의 상태 “ « std::endl;
  print_list(lst);</p>

<p>for (std::list<int>::iterator itr = lst.begin(); itr != lst.end(); ++itr) {
    // 만일 현재 원소가 20 이라면
    // 그 앞에 50 을 집어넣는다.
    if (*itr == 20) {
      lst.insert(itr, 50);
    }
  }</int></p>

<p>std::cout « “값이 20 인 원소 앞에 50 을 추가 “ « std::endl;
  print_list(lst);</p>

<p>for (std::list<int>::iterator itr = lst.begin(); itr != lst.end(); ++itr) {
    // 값이 30 인 원소를 삭제한다.
    if (*itr == 30) {
      lst.erase(itr);
      break;
    }
  }</int></p>

<p>std::cout « “값이 30 인 원소를 제거한다” « std::endl;
  print_list(lst);
}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Result

</code></pre></div></div>
<p>처음 리스트의 상태
[ 10 20 30 40 ]
값이 20 인 원소 앞에 50 을 추가
[ 10 50 20 30 40 ]
값이 30 인 원소를 제거한다
[ 10 50 20 40 ]
```</p>

<h1 id="stack--queues"><a href="https://modoocode.com/223#page-heading-6">Stack &amp; Queues</a></h1>
<ul>
  <li>덱은 벡터와 비슷하게 O(1) 으로 임의의 위치의 원소에 접근할 수 있으며 맨 뒤에 원소를 추가/제거 하는 작업도 O(1) 으로 수행할 수 있습니다.</li>
  <li>뿐만아니라 벡터와는 다르게 맨 앞에 원소를 추가/제거 하는 작업 까지도 O(1)O(1) 으로 수행 가능합니다.</li>
  <li>임의의 위치에 있는 원소를 제거/추가 하는 작업은 벡터와 마찬가지로 O(n)O(n) 으로 수행 가능합니다</li>
  <li>그렇다면 덱이 벡터에 비해 모든 면에서 비교 우위에 있는 걸까요?</li>
  <li>안타깝게도 벡터와는 다르게 덱의 경우 원소들이 실제로 메모리 상에서 연속적으로 존재하지는 않습니다.</li>
  <li>이 때문에 원소들이 어디에 저장되어 있는지에 대한 정보를 보관하기 위해 추가적인 메모리가 더 필요로 합니다.</li>
  <li>실제 예로, 64 비트 libc++ 라이브러리의 경우 1 개의 원소를 보관하는 덱은 그 원소 크기에 비해 8 배나 더 많은 메모리를 필요로 합니다).</li>
  <li><strong>즉 덱은 실행 속도를 위해 메모리를 (많이) 희생하는 컨테이너라 보면 됩니다.</strong>
<a href="https://postimg.cc/xkX3GfnP"><img src="https://i.postimg.cc/VNRZ8vh2/321312312.png" width="700px" title="source: imgur.com" /></a></li>
  <li>벡터와는 다르게 원소들이 메모리에 연속되어 존재하는 것이 아니라 일정 크기로 잘려서 각각의 블록 속에 존재합니다.</li>
  <li>따라서 이 블록들이 메모리 상에 어느 곳에 위치하여 있는지 저장하기 위해서 각각의 블록들의 주소를 저장하는 벡터가 필요로 합니다.</li>
  <li>존의 벡터와는 조금 다르게, 새로 할당 시에 앞쪽 및 뒤쪽 모두에 공간을 남겨놓게 됩니다. (벡터의 경우 뒤쪽에만 공간이 남았지요) 따라서 이를 통해 맨 앞과 맨 뒤에 O(1) 의 속도로 insert 및 erase 를 수행할 수 있는 것입니다.</li>
  <li>그렇다면 왜 덱이 벡터 보다 원소를 삽입하는 작업이 더 빠른 것일까요?
<a href="https://postimg.cc/tsvhgY8z"><img src="https://i.postimg.cc/FKNGDSZw/132321.png" width="700px" title="source: imgur.com" /></a></li>
  <li>위와 같은 상황에서 deq.push_back(10) 을 수행하였다고 생각해봅시다.
<a href="https://postimg.cc/pyZN6HwH"><img src="https://i.postimg.cc/J4w1t7KG/2222.png" width="700px" title="source: imgur.com" /></a></li>
</ul>

<p>REFERENCE</p>

<p><a href="https://modoocode.com/223">모두의코드</a></p>
:ET