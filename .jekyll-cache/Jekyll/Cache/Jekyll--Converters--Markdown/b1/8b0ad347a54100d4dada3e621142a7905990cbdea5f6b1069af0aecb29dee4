I"<h1 id="standard-template-library-stl"><a href="https://modoocode.com/223">Standard Template Library (STL)</a></h1>
<ul>
  <li>C++ 표준 라이브러리를 보면 꽤나 많은 종류의 라이브러리들이 있습니다.</li>
  <li>대표적으로 입출력 라이브러리 (iostream 등등), 시간 관련 라이브러리 (chrono), 정규표현식 라이브러리 (regex) 등등 들이 있지요.</li>
  <li>하지만 보통 C++ 템플릿 라이브러리(STL)를 일컫는다면 다음과 같은 세 개의 라이브러리들을 의미합니다
    <ul>
      <li>임의 타입의 객체를 보관할 수 있는 컨테이너 (container)</li>
      <li>컨테이너에 보관된 원소에 접근할 수 있는 반복자 (iterator)</li>
      <li>반복자들을 가지고 일련의 작업을 수행하는 알고리즘 (algorithm)</li>
    </ul>
  </li>
  <li>EX
    <ul>
      <li>편지를 보관하는 각각의 편지함들은 ‘컨테이너’</li>
      <li>편지를 보고 원하는 편지함을 찾는 일은 ‘반복자’</li>
      <li>편지들을 편지함에 날짜 순서로 정렬하여 넣는 일은 ‘알고리즘’</li>
    </ul>
  </li>
  <li>임의 타입의 객체를 보관할 수 있는 컨테이너 (container)
    <ul>
      <li>우리가 다루려는 객체가 어떤 특성을 갖는지 무관하게 라이브러리를 자유롭게 사용할 수 있다는 것입니다 (because of Template).</li>
      <li>만일 사용하려는 자료형이 int 나 string 과 같은 평범한 애들이 아니라, 우리가 만든 임의이 클래스의 객체들이여도 자유롭게 위 라이브러리의 기능들을 모두 활용할 수 있습니다.</li>
    </ul>
  </li>
  <li>반복자의 도입으로 알고리즘 라이브러리에 필요한 최소한의 코드만을 작성할 수 있게 되었습니다.
    <ul>
      <li>존의 경우 M 개 종류의 컨테이가 있고 N 종류의 알고리즘이 있다면 이 모든 것을 지원하려면 MN 개의 알고리즘 코드가 있어야만 했습니다.</li>
      <li>반복자를 이용해서 컨테이너를 추상화 시켜서 접근할 수 있기 때문에 N 개의 알고리즘 코드 만으로 M 종류의 컨테이너들을 모두 지원할 수 있게됩니다.</li>
    </ul>
  </li>
</ul>

<h2 id="stl-컨테이너---vectorstdvector"><a href="https://modoocode.com/223">STL 컨테이너 - Vector(STD::vector)</a></h2>
<ul>
  <li>C++ STL 에서 컨테이너는 크게 두 가지 종류가 있습니다.
    <ul>
      <li>먼저 배열 처럼 객체들을 순차적으로 보관하는 시퀀스 컨테이너 (sequence container)</li>
      <li>키를 바탕으로 대응되는 값을 찾아주는 연관 컨테이너 (associative container) 가 있습니다.</li>
    </ul>
  </li>
  <li>시퀀스 컨테이너의 경우 vector, list, deque 이렇게 3 개가 정의되어 있습니다.
    <ul>
      <li>(vector) 의 경우, 쉽게 생각하면 가변길이 배열이</li>
      <li>벡터에는 원소들이 메모리 상에서 실제로 순차적으로 저장되어 있고, 따라서 임의의 위치에 있는 원소를 접근하는 것을 매우 빠르게 수행할 수 있습니다.</li>
    </ul>
  </li>
  <li>vector 의 경우, 임의의 위치에 있는 원소에 접근을 O(1) 로 수행할 수 있습니다. 게다가 맨 뒤에 새로운 원소를 추가하거나 제거하는 것 역시 O(1) 에 수행합니다.</li>
  <li>vector 의 임의의 원소에 접근하는 것은 배열처럼 [] 를 이용하거나, at 함수를 이용하면 됩니다.</li>
  <li>또한 맨 뒤에 원소를 추가하거나 제거하기 위해서는 push_back 혹은 pop_back 함수를 사용하면 됩니다. 아래 예를 보겠습니다</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; vec;
  vec.push_back(10);  // 맨 뒤에 10 추가
  vec.push_back(20);  // 맨 뒤에 20 추가
  vec.push_back(30);  // 맨 뒤에 30 추가
  vec.push_back(40);  // 맨 뒤에 40 추가

  for (std::vector&lt;int&gt;::size_type i = 0; i &lt; vec.size(); i++) {
    std::cout &lt;&lt; "vec 의 " &lt;&lt; i + 1 &lt;&lt; " 번째 원소 :: " &lt;&lt; vec[i] &lt;&lt; std::endl;
  }
}
</code></pre></div></div>
<ul>
  <li>벡터의 크기를 리턴하는 함수인 size 의 경우, 그리턴하는 값의 타입은 size_type 멤버 타입으로 정의되어 있습니다.</li>
  <li>맨 뒤에 원소를 추가하는 작업은 엄밀히 말하자면 amortized O(1) 이라고 합니다. (amortized 의 뜻은 분할상환이란 뜻)</li>
  <li>왜냐면 보통은 vector 의 경우 현재 가지고 있는 원소의 개수 보다 더 많은 공간을 할당해 놓고 있습니다.</li>
  <li>예를 들어 현재 vector 에 있는 원소의 개수가 10 개라면 이미 20개를 저장할 수 있는 공간을 미리 할당해놓게됩니다.</li>
  <li>따라서 만약에 뒤에 새로운 원소를 추가하게 된다면 새롭게 메모리를 할당할 필요가 없이, 그냥 이미 할당된 공간에 그 원소를 쓰기만 하면 됩니다.</li>
  <li>따라서 대부분의 경우 O(1) 으로 vector 맨 뒤에 새로운 원소를 추가하거나 지울 수 있습니다.</li>
  <li>문제가 되는 상황은 할당된 공간을 다 채웠을 때 입니다.</li>
  <li>이 때는 어쩔 수 없이, 새로운 큰 공간을 다시 할당하고, 기존의 원소들을 복사하는 수 밖에 없습니다.</li>
  <li>따라서 이 경우 n 개의 원소를 모두 복사해야 하기 때문에 O(n) 으로 수행됩니다.</li>
  <li>하지만 이 O(n) 으로 수행되는 경우가 매우 드물기 때문에, 전체적으로 평균을 내보았을 때 O(1) 으로 수행됨을 알 수 있습니다.</li>
</ul>
:ET