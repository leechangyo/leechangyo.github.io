I"ò<<h1 id="templates"><a href="http://tcpschool.com/cpp/cpp_template_function">Templates</a></h1>
<ul>
  <li>í…œí”Œë¦¿(template)ì´ë€ ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì— ë”°ë¼ í•¨ìˆ˜ë‚˜ í´ë˜ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.</li>
  <li>í…œí”Œë¦¿ì€ íƒ€ì…ì´ ë§¤ê°œë³€ìˆ˜ì— ì˜í•´ í‘œí˜„ë˜ë¯€ë¡œ, ë§¤ê°œë³€ìˆ˜í™” íƒ€ì…(parameterized type)ì´ë¼ê³ ë„ ë¶ˆë¦½ë‹ˆë‹¤</li>
  <li>í…œí”Œë¦¿ì„ ì‚¬ìš©í•˜ë©´ íƒ€ì…ë§ˆë‹¤ ë³„ë„ì˜ í•¨ìˆ˜ë‚˜ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì§€ ì•Šê³ , ì—¬ëŸ¬ íƒ€ì…ì—ì„œ ë™ì‘í•  ìˆ˜ ìˆëŠ” ë‹¨ í•˜ë‚˜ì˜ í•¨ìˆ˜ë‚˜ í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.</li>
</ul>

<h2 id="2-function-templateí•¨ìˆ˜-í…œí”Œë¦¿">2. Function Template(í•¨ìˆ˜ í…œí”Œë¦¿)</h2>
<ul>
  <li>C++ì—ì„œ í•¨ìˆ˜ í…œí”Œë¦¿(function template)ì´ë€ í•¨ìˆ˜ì˜ ì¼ë°˜í™”ëœ ì„ ì–¸ì„ ì˜ë¯¸í•©ë‹ˆë‹¤</li>
  <li>í•¨ìˆ˜ í…œí”Œë¦¿ì„ ì‚¬ìš©í•˜ë©´ ê°™ì€ ì•Œê³ ë¦¬ì¦˜ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©´ì„œ, ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì—ì„œ ë™ì‘í•˜ëŠ” í•¨ìˆ˜ë¥¼ í•œ ë²ˆì— ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
  <li>ì„ì˜ì˜ íƒ€ì…ìœ¼ë¡œ ì‘ì„±ëœ í•¨ìˆ˜ì— íŠ¹ì • íƒ€ì…ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•˜ë©´, C++ ì»´íŒŒì¼ëŸ¬ëŠ” í•´ë‹¹ íƒ€ì…ì— ë§ëŠ” í•¨ìˆ˜ë¥¼ ìƒì„±í•´ ì¤ë‹ˆë‹¤</li>
</ul>

<blockquote>
  <p>ë¬¸ë²•
```
template <typename íƒ€ì…ì´ë¦„=""></typename></p>
</blockquote>

<p>í•¨ìˆ˜ì˜ ì›í˜•</p>

<p>{</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// í•¨ìˆ˜ì˜ ë³¸ì²´
</code></pre></div></div>

<p>}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- ìœ„ì—ì„œ ì •ì˜ëœ íƒ€ì… ì´ë¦„ì€ í•¨ìˆ˜ì˜ ì›í˜•ê³¼ ë³¸ì²´ì—ì„œ ì„ì˜ì˜ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- **ì´ë ‡ê²Œ ì •ì˜ëœ í•¨ìˆ˜ í…œí”Œë¦¿ì„ í˜¸ì¶œí•  ë•Œ ë§¤ê°œë³€ìˆ˜ë¡œ intí˜•ì„ ì „ë‹¬í•˜ë©´, í•¨ìˆ˜ì˜ ì›í˜•ê³¼ ë³¸ì²´ì—ì„œ ì •ì˜ëœ íƒ€ì… ì´ë¦„ì€ ëª¨ë‘ intí˜•ìœ¼ë¡œ ë°”ë€Œê²Œ ë©ë‹ˆë‹¤.**

&gt; ì˜ˆì œ

</code></pre></div></div>
<p>template <typename T=""></typename></p>

<p>void Swap(T&amp; a, T&amp; b);</p>

<p>int main(void)</p>

<p>{</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int c = 2, d = 3;

cout &lt;&lt; "c : " &lt;&lt; c &lt;&lt; ", d : " &lt;&lt; d &lt;&lt; endl;

Swap(c, d);

cout &lt;&lt; "c : " &lt;&lt; c &lt;&lt; ", d : " &lt;&lt; d &lt;&lt; endl;



string e = "hong", f = "kim";

cout &lt;&lt; "e : " &lt;&lt; e &lt;&lt; ", f : " &lt;&lt; f &lt;&lt; endl;

Swap(e, f);

cout &lt;&lt; "e : " &lt;&lt; e &lt;&lt; ", f : " &lt;&lt; f &lt;&lt; endl;

return 0;
</code></pre></div></div>

<p>}</p>

<p>template <typename T=""></typename></p>

<p>void Swap(T&amp; a, T&amp; b)</p>

<p>{</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T temp;

temp = a;

a = b;

b = temp;
</code></pre></div></div>

<p>}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&gt; ì‹¤í–‰ ê²°ê³¼

</code></pre></div></div>
<p>c : 2, d : 3</p>

<p>c : 3, d : 2</p>

<p>e : hong, f : kim</p>

<p>e : kim, f : hong</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- í•¨ìˆ˜ í…œí”Œë¦¿ì´ ê°ê°ì˜ íƒ€ì…ì— ëŒ€í•´ ì²˜ìŒìœ¼ë¡œ í˜¸ì¶œë  ë•Œ, C++ ì»´íŒŒì¼ëŸ¬ëŠ” í•´ë‹¹ íƒ€ì…ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
- ì´ë ‡ê²Œ ìƒì„±ëœ ì¸ìŠ¤í„´ìŠ¤ëŠ” í•´ë‹¹ íƒ€ì…ì— ëŒ€í•´ íŠ¹ìˆ˜í™”ëœ í…œí”Œë¦¿ í•¨ìˆ˜ì…ë‹ˆë‹¤.
- ì´ ì¸ìŠ¤í„´ìŠ¤ëŠ” í•¨ìˆ˜ í…œí”Œë¦¿ì— í•´ë‹¹ íƒ€ì…ì´ ì‚¬ìš©ë  ë•Œë§ˆë‹¤ í˜¸ì¶œë©ë‹ˆë‹¤.

## 3. ëª…ì‹œì  íŠ¹ìˆ˜í™”(explicit specialization)
- C++ì˜ í•¨ìˆ˜ í…œí”Œë¦¿ì€ íŠ¹ì • íƒ€ì…ì— ëŒ€í•œ ëª…ì‹œì  íŠ¹ìˆ˜í™”ë¥¼ ì œê³µí•˜ì—¬, í•´ë‹¹ íƒ€ì…ì— ëŒ€í•´ íŠ¹ë³„í•œ ë™ì‘ì„ ì •ì˜í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.
- ì»´íŒŒì¼ëŸ¬ëŠ” í˜¸ì¶œëœ í•¨ìˆ˜ì— ì •í™•íˆ ëŒ€ì‘í•˜ëŠ” íŠ¹ìˆ˜í™”ëœ ì •ì˜ë¥¼ ë°œê²¬í•˜ë©´, ë”ëŠ” í…œí”Œë¦¿ì„ ì°¾ì§€ ì•Šê³  í•´ë‹¹ ì •ì˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ì•ì„œ ì •ì˜ëœ í•¨ìˆ˜ í…œí”Œë¦¿ Swapì˜ doubleí˜•ì— ëŒ€í•œ ëª…ì‹œì  íŠ¹ìˆ˜í™”ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

&gt; í•¨ìˆ˜ í…œí”Œë¦¿ ì›í˜•

</code></pre></div></div>
<p>template <typename T=""></typename></p>

<p>void Swap(T&amp; a, T&amp; b);</p>

<p>template <typename T=""> void Swap(T&amp; a, T&amp; b);</typename></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&gt; doubleí˜•ì„ ìœ„í•œ ëª…ì‹œì  íŠ¹ìˆ˜í™”

</code></pre></div></div>
<p>template &lt;&gt; void Swap<double>(double&amp;, double&amp;) { ... };</double></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
# [Typedef](https://wikidocs.net/419)
- typedefëŠ” ìƒˆë¡œìš´ íƒ€ì…ì„ ë§Œë“œëŠ” ê²ƒì´ ì•„ë‹ˆë¼ íƒ€ì…ì˜ ìƒˆë¡œìš´ ë³„ì¹­ì„ ì •ì˜í•˜ëŠ” í‚¤ì›Œë“œ ì…ë‹ˆë‹¤
</code></pre></div></div>
<p>typedef int TypedefInt;
TypedefInt a;</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- ì´ í‚¤ì›Œë“œê°€ í…œí”Œë¦¿ê³¼ ë¬´ìŠ¨ ê´€ê³„ì¸ì§€ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤
- typedefëŠ” í´ë˜ìŠ¤ ì•ˆì—ì„œ íƒ€ì…ì˜ ìƒˆë¡œìš´ ë³„ì¹­ì„ ì§€ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤

</code></pre></div></div>
<p>class MyTypeClass
 {
 public:
     typedef int Type1;
 };
 int main()
 {
     MyTypeClass a;
     MyTypeClass::Type1 b;
     return 0;
 }</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- aëŠ” MyTypeClassì˜ ê°ì²´, bëŠ” int ë³€ìˆ˜

</code></pre></div></div>
<p>class MyTypeClass
{
public:
    typedef int Type1;
private:
    typedef double Type2;
};
int main()
{
    MyTypeClass a;
    MyTypeClass::Type1 b;
    MyTypeClass::Type2 c;  //ì—ëŸ¬
    return 0;
}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>
<p>class MyTypeClass
{
public:
    typedef int Type1;
    void f()
    {
        Type2 c;
    }
private:
    typedef double Type2;
};
int main()
{
    MyTypeClass a;
    MyTypeClass::Type1 b;
    return 0;
}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- typedefì€ í´ë˜ìŠ¤ ì•ˆì—ì„œë„ íƒ€ì…ì˜ ë³„ì¹­ì„ ë§Œë“¤ ìˆ˜ ìˆì„ ë¿ ì•„ë‹ˆë¼ ì™¸ë¶€ì ‘ê·¼ ì œí•œ ê¹Œì§€ ì˜í–¥ì„ ë°›ìŠµë‹ˆë‹¤.
- typedefëŠ” í…œí”Œë¦¿ íŒŒë¼ë¯¸í„°ë¡œ ë°›ì€ ë°ì´í„° íƒ€ì…ì´ í•„ìš”í•  ë•Œê°€ ìˆìŠµë‹ˆë‹¤

</code></pre></div></div>
<p>#include <iostream></iostream></p>

<p>template<typename T="">
class MyTempClass
{
public:
    typedef T TempType;
};
int main()
{
    MyTempClass<int> a;
    MyTempClass<int>::TempType b;
    MyTempClass<double> c;
    MyTempClass<double>::TempType d;
    return 0;
}</double></double></int></int></typename></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- ì´ë ‡ê²Œ íƒ€ì…ì•ˆì— íƒ€ì…ì˜ ê°ì²´ë¥¼ í˜¸ì¶œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. **ì´ë ‡ê²Œ í…œí”Œë¦¿ ë§¤ê°œë³€ìˆ˜ì— ì¢…ì†ëœ ê²ƒì„ ì˜ì¡´ ì´ë¦„(dependent name)** ì´ë¼ê³  í•©ë‹ˆë‹¤
- í´ë˜ìŠ¤ì•ˆì— ì¤‘ì²©ëœ ê²½ìš°ê°€ ìˆëŠ”ë° **ì¤‘ì²© ì˜ì¡´ ì´ë¦„(nested dependent name)** ì´ë¼ê³  í•©ë‹ˆë‹¤.
- í™•íˆ í•˜ë©´ í´ë˜ìŠ¤ ì•ˆì— TempType ì´ë¼ëŠ” íƒ€ì…ì´ ìˆìœ¼ë‹ˆê¹Œ **ì¤‘ì²© ì˜ì¡´ íƒ€ì… ì´ë¦„(nested dependent type name)** ì´ë¼ê³  í•©ë‹ˆë‹¤.

# Exercise 1

&gt; main.cpp

</code></pre></div></div>
<p>#include <iostream>
#include "point.h"</iostream></p>

<p>using namespace std;
/* function templates generalization*/</p>

<p>void operationOnPoints();</p>

<p>template&lt;typename T, typename T2&gt;
T add(T var1, T2 var2)
{
    return var1 + var2;
}
/*
template&lt;&gt;
Point2D add(Point2D var1, Point2D var2)
{
    Point2D tmp;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tmp.setX(var1.getX() + var2.getX());
tmp.setY(var1.getY() + var2.getY());

return tmp; } */ typedef Point&lt;int&gt; PointInt; int main() {
operationOnPoints();

//cout &lt;&lt; add&lt;double, double&gt;(2, 5.6) &lt;&lt; endl;
</code></pre></div></div>

<p>// cout Â«Â static_cast<int>(6.5) &lt;&lt; endl;</int></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return 0; } void operationOnPoints() {  //   PointInt a(5);
Point&lt;int*&gt; b(49);

//cout &lt;&lt; a.getX() &lt;&lt; endl;
//cout &lt;&lt; b.getX() &lt;&lt; endl; }
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&gt; point.h

</code></pre></div></div>
<p>#ifndef POINT_H_INCLUDED
#define POINT_H_INCLUDED
#include <iostream></iostream></p>

<p>using namespace std;</p>

<p>template<typename T="">
class Point //base, parent, superclass
{
    protected:
        T x;
    public:
        Point(T =0);
        ~Point();
        T getX();
        void setX(T);
};
template<typename T="">
Point<T>::Point(T x)
{
    this-&gt;x = x;
    cout &lt;&lt; "The constructor from the Point class has just been invoked" &lt;&lt; endl;
}
template<typename T="">
Point<T>::~Point()
{
    cout &lt;&lt; "The destructor from the Point class has just been invoked" &lt;&lt; endl;
}
template<typename T="">
void Point<T>::setX(T x)
{
    this-&gt;x = x;
    cout &lt;&lt; "Im from Point" &lt;&lt; endl;
}
template<typename T="">
T Point<T>::getX()
{
    return this-&gt;x;
}
template&lt;&gt;
double Point<double>::getX()
{
    cout &lt;&lt;"this function will be executed only when Point<double>" &lt;&lt; endl;
    return this-&gt;x;
}</double></double></T></typename></T></typename></T></typename></T></typename></typename></p>

<p>template<typename K="">
class Point&lt;K*&gt;
{
    public:
        Point(K a=0) { cout &lt;&lt; "you can't use pointers here"; }
};</typename></p>

<p>template <typename T="">
class Point2D : public Point<T> //derived, child, subclass
{
    protected:
        T y;
    public:
        Point2D(T =0, T =0);
        ~Point2D();
        T getY() { return y; }
        void setY(T);
        void setX(T);
        void setXY(T, T);
        Point2D operator+(Point2D);</T></typename></p>

<p>};
template <typename T="">
Point2D<T>::Point2D(T x, T y) : Point<T>(x)
{
    this-&gt;y = y;
    cout &lt;&lt; "The constructor from the Point2D class has just been invoked" &lt;&lt; endl;
}
template <typename T="">
Point2D<T>::~Point2D()
{
    cout &lt;&lt; "The destructor from the Point2D class has just been invoked" &lt;&lt; endl;
}
template <typename T="">
void Point2D<T>::setY(T y)
{
    this-&gt;y = y;
}
template <typename T="">
void Point2D<T>::setXY(T x, T y)
{
    setX(x);
    setY(y);
}
template <typename T="">
void Point2D<T>::setX(T x)
{
    this-&gt;x = x;
    cout &lt;&lt; "Im from Point2D" &lt;&lt; endl;
}
template <typename T="">
Point2D<T> Point2D<T>::operator+(Point2D o)
{
    Point2D tmp;</T></T></typename></T></typename></T></typename></T></typename></T></typename></T></T></typename></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tmp.setX(this-&gt;getX() + o.getX());
tmp.setY(this-&gt;getY() + o.getY());

return tmp; } /* class Point3D : public Point2D {
</code></pre></div></div>

<p>};
*/</p>

<p>template&lt;&gt;
class Point<char>
{
        public:
            Point(char a=0) { cout &lt;&lt; "this is from Point<char>";}
};
/*
    class Point2D : public Point
    everything what is inside Point (excluding constructor and destructor) will be in Point2D
    private - CANNOT ACCESS
    protected - protected
    public - public</char></char></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point2D : protected Point
everything what is inside Point (excluding constructor and destructor) will be in Point2D
private - CANNOT ACCESS
protected - protected
public - protected


class Point2D : private Point
everything what is inside Point (excluding constructor and destructor) will be in Point2D
private - CANNOT ACCESS
protected - private
public - private
</code></pre></div></div>

<p>*/
#endif // POINT_H_INCLUDED</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
# Exercise 2

&gt; main.cpp

</code></pre></div></div>
<p>#include <iostream>
#include "point.h"</iostream></p>

<p>using namespace std;
/* function templates generalization*/</p>

<p>void operationOnPoints();</p>

<p>template&lt;typename T, typename T2&gt;
T add(T var1, T2 var2)
{
    return var1 + var2;
}
/*
template&lt;&gt;
Point2D add(Point2D var1, Point2D var2)
{
    Point2D tmp;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tmp.setX(var1.getX() + var2.getX());
tmp.setY(var1.getY() + var2.getY());

return tmp; } */ int main() {
operationOnPoints();

//cout &lt;&lt; add&lt;double, double&gt;(2, 5.6) &lt;&lt; endl;
</code></pre></div></div>

<p>// cout Â«Â static_cast<int>(6.5) &lt;&lt; endl;</int></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return 0; } void operationOnPoints() {
Point2D p1(10, 67);
Point2D p2(50, 3); // 60,70

Point2D sum = add(p1,p2);

cout &lt;&lt; sum.getX() &lt;&lt; endl;
cout &lt;&lt; sum.getY() &lt;&lt; endl;
</code></pre></div></div>

<p>}</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&gt; point.h

</code></pre></div></div>
<p>#ifndef POINT_H_INCLUDED
#define POINT_H_INCLUDED</p>

<p>class Point //base, parent, superclass
{
    protected:
        int x;
    public:
        Point(int =0);
        ~Point();
        int getX() { return x; }
        void setX(int);
};
class Point2D : public Point //derived, child, subclass
{
    protected:
        int y;
    public:
        Point2D(int =0, int =0);
        ~Point2D();
        int getY() { return y; }
        void setY(int);
        void setX(int);
        void setXY(int, int);
        Point2D operator+(Point2D);</p>

<p>};
class Point3D : public Point2D
{</p>

<p>};</p>

<p>/*
    class Point2D : public Point
    everything what is inside Point (excluding constructor and destructor) will be in Point2D
    private - CANNOT ACCESS
    protected - protected
    public - public</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Point2D : protected Point
everything what is inside Point (excluding constructor and destructor) will be in Point2D
private - CANNOT ACCESS
protected - protected
public - protected


class Point2D : private Point
everything what is inside Point (excluding constructor and destructor) will be in Point2D
private - CANNOT ACCESS
protected - private
public - private
</code></pre></div></div>

<p>*/
#endif // POINT_H_INCLUDED</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&gt; point.cpp

</code></pre></div></div>
<p>#include <iostream>
#include "point.h"</iostream></p>

<p>using namespace std;</p>

<p>Point::Point(int x)
{
    this-&gt;x = x;
    cout Â«Â â€œThe constructor from the Point class has just been invokedâ€ Â«Â endl;
}
Point::~Point()
{
    cout Â«Â â€œThe destructor from the Point class has just been invokedâ€ Â«Â endl;
}
void Point::setX(int x)
{
    this-&gt;x = x;
    cout Â«Â â€œIm from Pointâ€ Â«Â endl;
}</p>

<p>Point2D::Point2D(int x, int y) : Point(x)
{
    this-&gt;y = y;
    cout Â«Â â€œThe constructor from the Point2D class has just been invokedâ€ Â«Â endl;
}
Point2D::~Point2D()
{
    cout Â«Â â€œThe destructor from the Point2D class has just been invokedâ€ Â«Â endl;
}</p>

<p>void Point2D::setY(int y)
{
    this-&gt;y = y;
}
void Point2D::setXY(int x, int y)
{
    setX(x);
    setY(y);
}
void Point2D::setX(int x)
{
    this-&gt;x = x;
    cout Â«Â â€œIm from Point2Dâ€ Â«Â endl;
}
Point2D Point2D::operator+(Point2D o)
{
    Point2D tmp;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tmp.setX(this-&gt;getX() + o.getX());
tmp.setY(this-&gt;getY() + o.getY());

return tmp; } ```
</code></pre></div></div>
:ET