I",0<h1 id="multi-agent-path-findingmapf">Multi-Agent path finding(MAPF)</h1>
<p><a href="https://postimg.cc/QF5ChNVj"><img src="https://i.postimg.cc/mgpH3ts1/image.png" width="700px" title="source: imgur.com" /></a></p>
<ul>
  <li>Multi-Agent(many robot) play to find the target position and move</li>
  <li>MAPF problem: Find a collision-free plan(path) for each agent</li>
  <li>Another name we called it : Cooperative path finding(CPF), Multi-robot path planning, pebble(鹅卵石) motion</li>
</ul>

<h2 id="1-introduction-to-mapf">1) Introduction to MAPF</h2>
<p><a href="https://postimg.cc/ZWRRvPfK"><img src="https://i.postimg.cc/bw02M3kb/51212413.png" width="700px" title="source: imgur.com" /></a></p>
<ul>
  <li>a graph (directed or undirected)</li>
  <li>a set of agents(robot), each agent is assigned to two locations(nodes) in the graph(start, destination)</li>
  <li>Each agent can perform either move(to a neighbouring node) or wait(in the same node) actions</li>
</ul>

<blockquote>
  <p>Typical Assumption:
 all move and wait actions have identical durations(plans for agents are synchronized)</p>
</blockquote>

<ul>
  <li><strong>Plan</strong> is a sequence of actions for the agent leading from its start location to its destination
    <ul>
      <li>the <strong>length of plan</strong>(for an agent) is defined by the time when the agent reaches its destination and does not leave it anymore.</li>
    </ul>
  </li>
  <li>Find <strong>Plans</strong> for all agents such that the plans <strong>do not collide in time and space</strong> (no two agents are at the same location at the same time)
<a href="https://postimg.cc/4mscxFjD"><img src="https://i.postimg.cc/Pr8QKgy5/50301230.png" width="500px" title="source: imgur.com" /></a></li>
  <li>some necessary <strong>conditions for plan existence</strong>:
    <ul>
      <li>no two agents are at the same start node</li>
      <li>no two agents share the same destination node(unless an agent disappears when reaching its destination)</li>
      <li>the number of agents is strictly smaller than the number of nodes</li>
    </ul>
  </li>
  <li>agent at $v_i$ cannot perform move $v_j$ at the same time when agent at $v_j$ perform move $v_i$</li>
  <li>Agents may swap position. but agents use the same edges at the same time, swap is not allowed
<a href="https://postimg.cc/qgyk5JDr"><img src="https://i.postimg.cc/FFn711jY/512124123.png" width="500px" title="source: imgur.com" /></a></li>
  <li>Agent can approach node that is currently occupied but will be free before arrival(Agent at $v_i$ cannot perform move $v_j$ if there is another agent at $v_j$)
<a href="https://postimg.cc/dDxxrrjt"><img src="https://i.postimg.cc/ZKbzkL93/5123124123.png" width="500px" title="source: imgur.com" /></a></li>
  <li>if any agent is delayed then trains may cause collision during execution</li>
  <li>to prevent such collisions we may introduce more space between agents</li>
</ul>

<h3 id="k-robustness">K-robustness</h3>
<p><a href="https://postimg.cc/3WNK3jwK"><img src="https://i.postimg.cc/J7ctcPVB/512512.png" width="500px" title="source: imgur.com" /></a></p>
<ul>
  <li>An agent can visit a node, if that node has not been occupied in recent <em>k</em> steps.</li>
  <li>1-robustness covers both no-swap and no-train constraints (1번밖에 못 거치는것)</li>
</ul>

<h3 id="other-constraints">Other constraints</h3>
<ul>
  <li>No Plan(path) has a cycle</li>
  <li>No Two plans(paths) visit the same location</li>
  <li>waiting is not allowed</li>
  <li>some specific locations must be visited</li>
</ul>

<h3 id="how-to-measure-quality-of-plans">How to Measure Quality of plans?</h3>
<p>There are two typical criteria(to minimize):
<a href="https://postimg.cc/QKBGcr4f"><img src="https://i.postimg.cc/8c4pQphg/05050.png" width="500px" title="source: imgur.com" /></a></p>
<ul>
  <li><strong>Makespan</strong>
    <ul>
      <li>distance between the start time of the first agent and the complete time of the last agent(아무개 에이전트의 시작과 아무개 에이전트의 마지막 동작)</li>
      <li>maximum of lengths of plans(end times)</li>
    </ul>
  </li>
  <li><strong>Sum of costs(SOC)</strong>
    <ul>
      <li>Sum of lengths of plans(end times)</li>
    </ul>
  </li>
  <li>Optimal single agent path finding is tractable(易处理的)
    <ul>
      <li>e.g. Dijkstra’s algorithm</li>
    </ul>
  </li>
  <li>Sub-optimal Multi-Agent path finding(with two free unoccupied nodes) is tractable
    <ul>
      <li>e.g algorithm Push and Rotate</li>
    </ul>
  </li>
  <li>MARF, where agents have joint goal nodes(it does not matter which agent reaches which goal) is tractable
    <ul>
      <li>reduction to min-cost flow problem</li>
    </ul>
  </li>
  <li>Optimal(Makespan,SOC) multi-agent path finding is <strong>NP-HARD</strong>
<a href="https://postimg.cc/HrtYYdfM"><img src="https://i.postimg.cc/jSpLhjcM/1511314.png" width="700px" title="source: imgur.com" /></a></li>
</ul>

<h3 id="solving-approaches">Solving approaches</h3>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<div align="center" style="margin: 1em 0;">
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5150894678574694" data-ad-slot="9221331439" data-ad-format="auto" data-full-width-responsive="true"></ins>
     </div>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<ol>
  <li><strong>Search-Based Techniques</strong>
    <ul>
      <li>state-space search(A*)
        <ul>
          <li>state = location of agents at nodes</li>
          <li>transition = performing one action for each agent</li>
        </ul>
      </li>
      <li>Conflict-based search</li>
    </ul>
  </li>
  <li>** Reduction-based Techniques
    <ul>
      <li>Translate the problem to another formalism(形式主义)
        <ul>
          <li>SAT/CSP/ASP …</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h2 id="2-search-based-solvers">2. Search-Based Solvers</h2>
<ul>
  <li>Search is a General Problem solving technique</li>
  <li>To expand or not expand, this is the question
<a href="https://postimg.cc/PN88tvK8"><img src="https://i.postimg.cc/h42819dM/511313.png" width="700px" title="source: imgur.com" /></a></li>
  <li>Why do we need <strong>SEARCH</strong> for MAPF? Because it is Finding an optimal solution to hundreds of agents</li>
  <li>this is classical application of Search
<a href="https://postimg.cc/gxf3yyMd"><img src="https://i.postimg.cc/5ttpVnLH/image.png" width="700px" title="source: imgur.com" /></a></li>
  <li>Solving Multi-Agent Path Finding with Search
<a href="https://postimg.cc/Q96tmhX5"><img src="https://i.postimg.cc/RhmHMZyP/5123124213.png" width="500px" title="source: imgur.com" /></a></li>
  <li>From A* to <strong>prioritized planners</strong></li>
  <li>From prioritized(按重要性排列) planners back to A*</li>
  <li>The <strong>Increasing Cost tree search</strong>(ICTS)</li>
  <li>The <strong>Conflict-Based Search</strong>(CBS) framework</li>
  <li>Approximately optimal search-based solvers
<a href="https://postimg.cc/XrVYRrpF"><img src="https://i.postimg.cc/mg91FM4d/51241241.png" width="500px" title="source: imgur.com" /></a></li>
  <li>Single Agent Search Problem Properties
    <ul>
      <li>Number of state = ? (it will be 4 )</li>
      <li>Branching factor = ? (4)
<a href="https://postimg.cc/JD1nLtTS"><img src="https://i.postimg.cc/nzmQqDqV/444-12.png" width="500px" title="source: imgur.com" /></a></li>
    </ul>
  </li>
  <li>Two Agent Search Problem Properties
    <ul>
      <li>Number of States = ? ($20^2$)</li>
      <li>Branching factor = ? ($5^2$)</li>
    </ul>
  </li>
  <li>then, What about <strong>K</strong> Agents?
    <ul>
      <li>Number of States = ($20^k$)</li>
      <li>Branching factor = ($5^k$)</li>
    </ul>
  </li>
  <li><strong>IT IS VERY HARD PROBLEM</strong></li>
  <li>SO Key Idea: Plan for each agent seperately</li>
  <li>Challenge: Maintaining soundness, completeness, and optimality
<a href="https://postimg.cc/xkH24Ynh"><img src="https://i.postimg.cc/MG3pXK46/5030123.png" width="500px" title="source: imgur.com" /></a></li>
</ul>

<h3 id="prioritized-planning-silver-2005-analysis-first-agent">Prioritized Planning (Silver 2005) Analysis: First Agent</h3>
<p><a href="https://postimg.cc/9rqJTfp6"><img src="https://i.postimg.cc/Kv0V6kg8/513121.png" width="500px" title="source: imgur.com" /></a></p>
<h3 id="prioritized-planning-silver-2005-analysis-second-agent">Prioritized Planning (Silver 2005) Analysis: Second Agent</h3>
<p><a href="https://postimg.cc/R3cFy2Bs"><img src="https://i.postimg.cc/0N4wMqHs/51212313.png" width="500px" title="source: imgur.com" /></a></p>

<ul>
  <li>Complexity?
    <ul>
      <li>Polynomial in the grid size and max time</li>
    </ul>
  </li>
  <li>Soundness?
    <ul>
      <li>Yes</li>
    </ul>
  </li>
  <li>Complete? Optimal?
    <ul>
      <li>No
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></li>
    </ul>
  </li>
</ul>
<div align="center" style="margin: 1em 0;">
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5150894678574694" data-ad-slot="9221331439" data-ad-format="auto" data-full-width-responsive="true"></ins>
     </div>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<ul>
  <li>Smart Agent <strong>Prioritization</strong>
    <ul>
      <li>conflict oriented WHCA*[Bnaya and Felner ‘14]</li>
      <li>Re-prioritization and safe intervals [Andreychuk and Yakovlev ‘18]</li>
    </ul>
  </li>
  <li>Integrate <strong>planning and execution</strong>
    <ul>
      <li>Windowed Hierarchical CA* [Silver ‘06]
<a href="https://postimg.cc/mPSZSCNJ"><img src="https://i.postimg.cc/cLpK0cKx/512314123213.png" width="700px" title="source: imgur.com" /></a></li>
    </ul>
  </li>
  <li>High-level idea : reservation-based planning (ex) Number of states = 4 x 5 x maxTime)</li>
  <li><strong>FAST</strong>, requires almost no coordination
    <ul>
      <li>but <strong>incomplete</strong> and not <strong>optimal</strong>
        <h3 id="search-based-solver-overview">Search based solver overview</h3>
        <p><a href="https://postimg.cc/LgB40PFJ"><img src="https://i.postimg.cc/7hjCh1Bn/51232131231.png" width="500px" title="source: imgur.com" /></a></p>
      </li>
    </ul>
  </li>
  <li>Can MARF algorithm be <strong>Complete</strong> and <strong>efficient</strong>?</li>
</ul>

<h3 id="mapf-as-a-puzzle">MAPF as a puzzle</h3>
<p><a href="https://postimg.cc/7G4SCg96"><img src="https://i.postimg.cc/B6LpVp1x/5112313123.png" width="500px" title="source: imgur.com" /></a></p>
<ul>
  <li>MAPF is highly related to <strong>pebble motion problems</strong>
    <ul>
      <li>Each agent is a pebble(조약돌)</li>
      <li>Need to move each pebble to its goal</li>
      <li>cannot put two pebbles in one hole</li>
    </ul>
  </li>
  <li><strong>Pebble Motion can be solved Polynomial</strong>
    <ul>
      <li>but far from optimally</li>
      <li>complex formulation</li>
    </ul>
  </li>
  <li>Similar approaches
    <ul>
      <li>slidable(滑动) Multi-Agent Path Planning[Wang &amp; Botea, IJCAI, 2009]</li>
      <li>Push and Swap [Luna &amp; Bekris, IJCAI, 2011]
        <ul>
          <li>Parallel push and swap [Sajid, Luna, and Bekris, SoCS 2012]</li>
          <li>Push and Rotate [de Wilde et al. AAMAS 2013]</li>
        </ul>
      </li>
      <li>Tree-based agent swapping strategy [Khorshid at el. SOCS, 2011]</li>
    </ul>
  </li>
</ul>

<h3 id="examples">Examples</h3>
<p><a href="https://postimg.cc/7G4SCg96"><img src="https://i.postimg.cc/B6LpVp1x/5112313123.png" width="700px" title="source: imgur.com" /></a></p>

<h3 id="search-based-solver-summary">Search based solver Summary</h3>
<p><a href="https://postimg.cc/PP9Jr9m4"><img src="https://i.postimg.cc/3xJv9HNP/5123124.png" width="700px" title="source: imgur.com" /></a></p>

<h3 id="can-a-mapf-algorithm-be-complete-and-efficient-and-optimal">Can a MAPF algorithm be complete and efficient and optimal?</h3>
<p><a href="https://postimg.cc/tYsr0nqc"><img src="https://i.postimg.cc/Nf4ZHRWQ/155123.png" width="700px" title="source: imgur.com" /></a></p>

<p>Reference: <a href="https://potassco.org/doc/start/">postassco</a></p>
:ET