I"@<h1 id="copy-constructor">Copy Constructor</h1>
<blockquote>
  <p>Main.cpp</p>
</blockquote>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include "test.h"

using namespace std;
/* COPY CONSTRUCTOR */

int main()
{

    int a = 10;
    int b = a;

    a = 60;

    cout &lt;&lt; "a : " &lt;&lt; a &lt;&lt; endl; //60
    cout &lt;&lt; "b : " &lt;&lt; b &lt;&lt; endl; //10

    Test obj1(50, 100, 60);
    Test obj2 = obj1;

    obj2.x = 200;
    *(obj1.p) = 700;

    cout &lt;&lt; "obj1.x " &lt;&lt; obj1.x &lt;&lt; endl;
    cout &lt;&lt; "*(obj1.p) " &lt;&lt; *(obj1.p) &lt;&lt; endl;
    cout &lt;&lt; "obj1.y " &lt;&lt; obj1.y &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; "obj2.x " &lt;&lt; obj2.x &lt;&lt; endl;
    cout &lt;&lt; "*(obj2.p)" &lt;&lt; *(obj2.p) &lt;&lt; endl;
    cout &lt;&lt; "obj2.y " &lt;&lt; obj2.y &lt;&lt; endl;


    return 0;
}


</code></pre></div></div>

<blockquote>
  <p>test.h</p>
</blockquote>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef TEST_H_INCLUDED
#define TEST_H_INCLUDED

class Test
{
    public:
        int x; //50
        int y; //100
        int *p; //60
        Test(const Test &amp;); //copy
        Test(int, int, int);
        ~Test();
};

#endif // TEST_H_INCLUDED

</code></pre></div></div>

<blockquote>
  <p>test.cpp</p>
</blockquote>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "test.h"

Test::Test(int x, int y, int value)
{
        this-&gt;x = x;
        this-&gt;y = y;
        this-&gt;p = new int(value); // because of in head file p is the *pointer
}
Test::~Test()
{
        delete p;
}
Test::Test(const Test &amp; obj) //copy
{
    this-&gt;p = new int(*(obj.p)); //because of in head file p is the *pointer
    this-&gt;x = obj.x;
    this-&gt;y = obj.y;
}

</code></pre></div></div>

<h1 id="constructorhttptcpschoolcomcppcpp_struct_intro">(CONSTRUCTOR)[http://tcpschool.com/cpp/cpp_struct_intro]</h1>
<ul>
  <li>구조체(structure type)란 사용자가 C++의 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 정의 타입입니다.</li>
  <li>배열이 같은 타입의 변수 집합이라고 한다면, 구조체는 다양한 타입의 변수 집합을 하나의 타입으로 나타낸 것입니다. 이때 구조체를 구성하는 변수를 <strong>구조체의 멤버(member)</strong> 또는 <strong>멤버 변수(member variable)</strong> 라고 합니다.</li>
  <li>C++의 구조체는 변수뿐만 아니라 함수까지도 멤버 변수로 가질 수 있습니다</li>
  <li>또한, C++의 구조체는 타입일 뿐만 아니라, 객체 지향 프로그래밍의 핵심이 되는 클래스(class)의 기초가 됩니다</li>
  <li>코드와 함께 설명하겠습니다.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div>    </div>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;

using namespace std;
/* DATA STRUCTURES */

struct personalData
{
    string name;
    string surname;
    string telephoneNumber;
    short age;
}a,b;
void test(personalData *);
int main()
{
    personalData person[5];
    a.age =50;

   // cout &lt;&lt; a.age &lt;&lt; endl;
    person[0].name = "Arkadiusz";
    person[1].name = "Wiola";
    person[0].surname = "Wlodarczyk";
    person[0].telephoneNumber = "606102340";
    person[0].age = 22;
/*
    cout &lt;&lt; person[0].name &lt;&lt; endl;
    cout &lt;&lt; person[0].surname &lt;&lt; endl;
    cout &lt;&lt; person[0].telephoneNumber &lt;&lt; endl;
    cout &lt;&lt; person[0].age &lt;&lt; endl;
*/
/*
    cout &lt;&lt; (*person).name &lt;&lt; endl;
    cout &lt;&lt; (*&amp;person[0]).name &lt;&lt; endl;
    cout &lt;&lt; (person+1)-&gt;name &lt;&lt; endl;
*/
    personalData *p = person;

    cout &lt;&lt; p-&gt;name &lt;&lt; endl;

    test(p); // test(person);

    cout &lt;&lt; p-&gt;name &lt;&lt; endl;
    return 0;
}
void test(personalData *person)
{
    person-&gt;name = "Agnes";
}
</code></pre></div></div>
:ET