I"¿Z<h1 id="pointer"><a href="https://ko.wikibooks.org/wiki/C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%9E%85%EB%AC%B8/%ED%8F%AC%EC%9D%B8%ED%84%B0">Pointer</a></h1>
<ul>
  <li>ë³€ìˆ˜(Variable)ê°€ ë¬´ì—‡ì¸ê°€? ë³€ìˆ˜ëŠ” <em>ë©”ëª¨ë¦¬ ê³µê°„</em> ì´ë‹¤. ì»´í“¨í„°ì— ê½ƒí˜€ìˆëŠ” RAM ë‚´ ì–´ë”˜ê°€ë¥¼ ì˜ë¯¸í•œë‹¤. ê·¸ë¦¬ê³  RAMì— ìˆëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì—ëŠ” ì¼ë ¨ë²ˆí˜¸ê°€ ë¶™ì–´ìˆê³ , ëª¨ë“  ë³€ìˆ˜ëŠ” ì¼ë ¨ë²ˆí˜¸ì™€ í¬ê¸°ê°€ ì •í•´ì ¸ìˆë‹¤. ë‹¨ì§€ ì¼ë ¨ë²ˆí˜¸ë¥¼ ì™¸ì›Œê°€ë©° í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•  ìˆ˜ ì—†ìœ¼ë‹ˆ ì¼ë ¨ë²ˆí˜¸ì™€ ì´ë¦„ì„ ë¹„êµí•˜ëŠ” ë¹„êµí‘œë¥¼ ì»´íŒŒì¼ëŸ¬ê°€ ì‘ì„±í•˜ê³ , í”„ë¡œê·¸ë˜ë¨¸ëŠ” ê·¸ ë¹„êµí‘œì— ìˆëŠ” ì´ë¦„ì„ ì™¸ì›Œì„œ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ë©´ ì»´íŒŒì¼ëŸ¬ê°€ ë‚˜ì¤‘ì— ì´ë¦„ì„ ì¼ë ¨ë³€í˜¸ë¡œ ë³€í™˜í•˜ëŠ” ì‘ì—…ì„ í•´ì¤€ë‹¤.</li>
  <li>í¬ì¸í„° ì—­ì‹œ ìœ„ì—ì„œ ì–¸ê¸‰í•œ ë³€ìˆ˜ì˜ í•œ ì¢…ë¥˜ì´ë‹¤. ë‹¤ë¥¸ ë³€ìˆ˜ì™€ì˜ ì°¨ì´ì ì´ë¼ë©´ ìœ„ì—ì„œ ë§í•œ â€˜ë©”ëª¨ë¦¬ ê³µê°„ì˜ ì¼ë ¨ë²ˆí˜¸â€™ë¥¼ ì €ì¥í•  ìˆ˜ ìˆëŠ” ë³€ìˆ˜ë‹¤. ì •ìˆ˜í˜• ë³€ìˆ˜ì—ëŠ” ì •ìˆ˜ê°’ì´, ë¶€ë™ì†Œìˆ˜í˜• ë³€ìˆ˜ì—ëŠ” ë¶€ë™ì†Œìˆ˜ ê°’ì´, ê·¸ë¦¬ê³  í¬ì¸í„°í˜• ë³€ìˆ˜ì—ëŠ” â€˜ë©”ëª¨ë¦¬ ê³µê°„ì˜ ì¼ë ¨ë²ˆí˜¸â€™ê°€ ì €ì¥ëœë‹¤.</li>
  <li>ì¦‰ â€˜í¬ì¸í„°=ë©”ëª¨ë¦¬ ê³µê°„ì˜ ì¼ë ¨ë²ˆí˜¸â€™</li>
  <li>ê·¸ëŸ¼ ë©”ëª¨ë¦¬ ê³µê°„ì˜ ì¼ë ¨ë³¸í˜¸ â€“ ì£¼ì†Œ ë”°ìœ„ë¥¼ ì €ì¥í•´ì„œ ë¬´ì—‡ì— ì“°ëƒë¼ëŠ” ë¬¸ì œê°€ ëŒ€ë‘ ëœë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ ì•Œì•„ì„œ ì´ë¦„ì„ ì£¼ì†Œë¡œ ë°”ê¾¸ì–´ì£¼ëŠ”ë° êµ³ì´ ì£¼ì†Œë¥¼ ë‹¤ë£¨ì–´ì•¼ í•  í•„ìš”ê°€ ìˆê² ëŠ”ê°€? ë‹µì€ ë³´ë‚˜ë§ˆë‚˜ â€˜ë¬¼ë¡ â€™ì´ë‹¤. ì²˜ìŒì— Cë¼ëŠ” ì–¸ì–´ëŠ” ìš´ì˜ì²´ì œë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ë§Œë“¤ì–´ì§„ ì–¸ì–´ì´ë©° í•˜ë“œì›¨ì–´ë¥¼ ë‹¤ë£¨ëŠ”ë° ê°€ì¥ ìœ ë¦¬í–ˆë˜ ì–¸ì–´ì´ë‹¤. í¬ì¸í„°ê°€ ë°”ë¡œ ê·¸ <strong>â€˜í•˜ë“œì›¨ì–´ë¥¼ ë‹¤ë£¨ëŠ” í˜â€™</strong> ì´ë‹¤.
    <h2 id="ê¸°ë³¸-í¬ì¸í„°">ê¸°ë³¸ í¬ì¸í„°</h2>
  </li>
  <li>â€˜ë³€ìˆ˜=ë©”ëª¨ë¦¬ ê³µê°„â€™ì´ê³  â€˜í¬ì¸í„°=ë©”ëª¨ë¦¬ ê³µê°„ì˜ ì£¼ì†Œë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜â€™ì´ì—ˆìœ¼ë‹ˆ, ê²°êµ­ í¬ì¸í„°ëŠ” <strong>â€˜ë³€ìˆ˜ì˜ ìœ„ì¹˜ë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜â€™</strong> ë¼ëŠ” ì˜ë¯¸ê°€ ëœë‹¤.</li>
  <li>ì•„ë˜ ì½”ë“œë¥¼ ì ì‹œ ë³´ì</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
int main (int argc, char * argv[])
{
    int var = 10;
    int *vp = &amp;var;

    printf("The value of pointer: %x\n", vp);
    printf("The value before: %d, %d\n", var, *vp);
    var = 20;
    printf("The value after: %d, %d\n", var, *vp);
    *vp = 30;
    printf("The value then: %d, %d\n", var, *vp);
    return 0;
}

</code></pre></div></div>
<ul>
  <li>5ë²ˆ ë¼ì¸ì—ì„œ vpë¼ëŠ” ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë©´ì„œ ì´ë¦„ ì•ì— (asterisk)ê°€ ë¶™ì–´ìˆëŠ” ê±¸ ë³¼ ìˆ˜ ìˆë‹¤. ì‹¤ìƒ ì´ ë³„í‘œì˜ íƒ€ì… ì¼ë¶€ë¡œ â€˜int (asterisk)â€™ê°€ í•˜ë‚˜ì˜ íƒ€ì…ì´ ëœë‹¤. â€˜int (asterisk)â€™ì˜ ì˜ë¯¸ëŠ” â€˜ì •ìˆ˜ê°’ì„ ì €ì¥í•˜ëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì˜ ì£¼ì†Œë¥¼ ì €ì¥í•  ìˆ˜ ìˆëŠ” ë³€ìˆ˜â€™ì´ë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ì´ìœ ì— ì˜í•´ â€˜ì£¼ì†Œê°€ ì €ì¥ë˜ëŠ” ë³€ìˆ˜â€™ì—ë„ ë¶ˆêµ¬í•˜ê³  ì¼ë°˜ì ì¸ ë³€ìˆ˜ì˜ íƒ€ì…ì´ ì¶”ê°€ë¡œ ë¶™ëŠ”ë‹¤.
    <ol>
      <li>ë³€ìˆ˜ì— íƒ€ì…ì´ ìˆëŠ” ì´ìœ ëŠ” ë³€ìˆ˜ì— ì €ì¥ë˜ì–´ìˆëŠ” ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ë°©ë²•ì„ ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì•Œë ¤ì£¼ê¸° ìœ„í•¨ì´ë‹¤</li>
      <li>í¬ì¸í„° ë³€ìˆ˜ì— ì£¼ì†Œë¥¼ ë„£ëŠ” ì´ìœ ëŠ” ê·¸ ì£¼ì†Œ ìì²´ê°€ í•„ìš” í•´ì„œê°€ ì•„ë‹ˆë¼ ì£¼ì†Œì— í•´ë‹¹ë˜ëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì— ì €ì¥ë˜ì–´ìˆëŠ” ë°ì´í„°ê°€ í•„ìš”í•´ì„œ ì´ë‹¤.</li>
      <li>ê²°êµ­ í¬ì¸í„° ë³€ìˆ˜ì— íƒ€ì…ì´ ì¡´ì¬í•˜ëŠ” ì´ìœ ëŠ” í¬ì¸í„° ë³€ìˆ˜ì— ì €ì¥ë˜ì–´ìˆëŠ” ì£¼ì†Œìœ„ì¹˜ì— ìˆëŠ” ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ë°©ë²•ì„ ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì•Œë ¤ì£¼ê¸° ìœ„í•¨ì´ë‹¤.</li>
    </ol>
  </li>
  <li>ë˜í•œ 5ë²ˆ ë¼ì¸ì—ì„œ vpì— ê°’ì„ ëŒ€ì…í•  ë•Œ &amp; ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤. &amp;ëŠ” ë ˆí¼ëŸ°ìŠ¤ ì—°ì‚°ì(reference operator)ë¼ ë¶€ë¥´ë©°, ë³€ìˆ˜ì˜ ì£¼ì†Œë¥¼ ì•Œì•„ë‚´ëŠ”ë° ì‚¬ìš©ëœë‹¤. ê²°êµ­ 5ë²ˆë¼ì¸ì€ â€˜ì •ìˆ˜í˜• í¬ì¸í„° vpë¥¼ ë§Œë“¤ê³ , varì˜ ì£¼ì†Œë¥¼ ì•Œì•„ë‚´ì„œ vpì— ì €ì¥í•œë‹¤â€™ ë¼ëŠ” ì˜ë¯¸ê°€ ëœë‹¤.</li>
  <li>ë°˜ë³µí•´ì„œ ì„¤ëª… ë˜ì—ˆë“¯ì´ í¬ì¸í„°ëŠ” ë©”ëª¨ë¦¬ ì£¼ì†Œ - ë©”ëª¨ë¦¬ ê³µê°„ì˜ ì¼ë ¨ë²ˆí˜¸ ì´ë‹¤. ê²°êµ­ vpì— ì €ì¥ë˜ëŠ” ê°’ì€ ì‹¤ì œë¡œëŠ” ì •ìˆ˜ê°’ ì´ë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— 7ë²ˆë¼ì¸ì— ë³´ëŠ” ê²ƒ ê³¼ ê°™ì´ ê·¸ ê°’ì„ ì¸ì‡„í•´ ë³´ë©´ ì •ìˆ˜ê°’ìœ¼ë¡œ ì¸ì‡„ëœë‹¤.</li>
  <li>8, 10, 12ë²ˆ ë¼ì¸ì— ê±¸ì³ì„œ ë³€ìˆ˜ vp ì•ì— * ì—°ì‚°ìê°€ ë¶™ì–´ìˆëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.[1] * ì—°ì‚°ìëŠ” í¬ì¸í„° ì—°ì‚°ìë¼ê³  í•˜ë©°, í¬ì¸í„°ë³€ìˆ˜ì— ì €ì¥ë˜ì–´ìˆëŠ” ë©”ëª¨ë¦¬ ì£¼ì†Œì— í•´ë‹¹ë˜ëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì— ì €ì¥ë˜ì–´ìˆëŠ” ê°’ì„ ì•¡ì„¸ìŠ¤ í•˜ë ¤ëŠ” ê²½ìš°ì— ì‚¬ìš©ëœë‹¤. ë³€ìˆ˜ vpì—ëŠ” ë³€ìˆ˜ varì˜ ì£¼ì†Œê°€ ì €ì¥ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ê²°êµ­ (asterisk)vpë¥¼ í†µí•´ ì•¡ì„¸ìŠ¤ë˜ëŠ” ë°ì´í„°ëŠ” varë¥¼ í†µí•´ ì•¡ì„¸ìŠ¤ ë˜ëŠ” ë°ì´í„°ì™€ ë™ì¼í•˜ë‹¤. 9ë²ˆê³¼ 11ë²ˆ ì—ì„œë³´ë©´ varë¥¼ ìˆ˜ì •í•´ì„œ ë³´ì—¬ì§€ëŠ” ê²°ê³¼ë‚œ (asterisk)vpë¥¼ í†µí•´ì„œ ìˆ˜ì •í•´ì„œ ë³´ì—¬ì§€ëŠ” ê²°ê³¼ë‚˜ ê°™ì€ ê²ƒì„ ë³´ë©´ ìœ ì¶”ê°€ ê°€ëŠ¥í•  ê²ƒ ì´ë‹¤.</li>
</ul>

<h1 id="double-pointer"><a href="https://www.quora.com/What-do-the-two-asterisks-signify-in-C++-when-passing-int-**array">Double Pointer</a></h1>
<ul>
  <li>consider this code
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int i = 42;
int *pi = &amp;i;
int **ppi = &amp;pi;
</code></pre></div>    </div>
  </li>
  <li>As you can see, the variable â€œiâ€ is an int which Iâ€™ve set to the value 42.</li>
  <li>pi is a <strong>pointer-to-int</strong>, which Iâ€™ve set to the address of i.</li>
  <li>ppi is a <strong>pointer-to-pointer-to-int</strong>, which Iâ€™ve set to the address of pi.</li>
  <li><em>So thatâ€™s all the double-asterisk means. It means â€œpointer-to-pointerâ€</em></li>
  <li><strong>A pointer is a variable that holds a memory address. A pointer to a pointer simply holds the memory address of another pointer.</strong></li>
  <li>In typical usage:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int i;
</code></pre></div>    </div>
  </li>
  <li>This is called a â€œscalarâ€ in computer science, which just means â€œan atomic quantity that can hold one value at a timeâ€.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int *pi;
</code></pre></div>    </div>
  </li>
  <li>This is <strong>typically an array of ints.</strong> That is, <strong>it is a variable that stores the memory location of a block of memory that stores a series of ints</strong>. Syntactically, the C++ language will let you treat <strong>pi as an array</strong>. Thus, you can write:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (int x = 0; x &lt; 10; ++x) pi[x] = x;
</code></pre></div>    </div>
  </li>
  <li>This would store the values 0, 1, 2, 3, etc. in the first 10 spots of the memory block pointed to by pi.</li>
  <li>so then,
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int **ppi;
</code></pre></div>    </div>
  </li>
  <li>When you see this in code, <strong>itâ€™s typically being used as a pointer to an array of pointers.</strong> In other words, <strong>a 2-dimensional array.</strong> <strong>It points to a block of memory that stores pointers, each of which points to a block of memory that stores ints.</strong> Again, C++ will let you treat it this way and write:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (int x = 0; x &lt; 10; ++x) {
  for (int y = 0; y &lt; 10; ++y) {
      ppi[y][x] = 42;
  }
}
</code></pre></div>    </div>
  </li>
  <li>Conceptually, what this is doing is setting all of the cells in a 10x10 block of a matrix to the value 42.</li>
  <li>Now, having said all of that, you asked â€œwhat does it mean when passingâ€¦.â€</li>
  <li>Consider this:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void func ( int i ) {
  // do something
}
</code></pre></div>    </div>
  </li>
  <li>Obviously, thatâ€™s a function that takes an integer argument. Simple.</li>
  <li>Now this:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void func ( int *pi ) {
  // do something
}
</code></pre></div>    </div>
  </li>
  <li>Without anything else to go on but this function declaration, there are two possibilities:
    <ol>
      <li>This is a function that takes an array of integers as an argument</li>
      <li>This is a function that takes an integer, passed by reference, as an argument.</li>
    </ol>
  </li>
  <li>â€œPassed by referenceâ€ means that rather than merely(ä»…ä»…) passing a value to the function, <strong>Iâ€™m going to pass a pointer to (a.k.a. â€œreference toâ€) the value.</strong>d <strong>The reason to do this is so that the function will have the power to change the value.</strong></li>
  <li>Hereâ€™s a super-simple usage that you might see:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private:
  int _myData;
public:
  void get_data ( int *pData ) {
     *pData = _myData;
  }
</code></pre></div>    </div>
  </li>
  <li>When calling get_data, <strong>youâ€™d pass it the address to the variable you want to store the data in</strong>, and the function would fill it in for you. Thatâ€™s why you pass it by reference.</li>
  <li>Now we come at last to this:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void func ( int **ppi ) {
  // do something
}
</code></pre></div>    </div>
  </li>
  <li>What is this? Well, itâ€™s either:
    <ol>
      <li>A function that takes a 2-dimensional array (matrix) of integers as an argument, or</li>
      <li>A function that takes an array of integers, passed by reference, as an argument</li>
    </ol>
  </li>
  <li>Once again, if itâ€™s the latter, the reason would be that the function needs the ability to change the memory address the array points to â€” that is, point it somewhere else.</li>
</ul>

<h1 id="example-1">Example 1</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;

using namespace std;
/* POINTERS ARE ordinary variables that can store addresses of variables */
int main()
{
    int var = 5;
    int a = 20;

    cout &lt;&lt; *&amp;var &lt;&lt; endl;

    int * const p = &amp;var; //that asterisk here is just used to INFORM about that this variable is a POINTER so it is a variable that can point to address of another variable

   // p = &amp;var;

    cout &lt;&lt; *p &lt;&lt; endl; //that asterisk here is used to RETRIEVE (GET) value FROM indicated (pointed) area in our memory (address)

    //*p = 20;
//    var = 60;
    *p = 60;
    cout &lt;&lt; "var: " &lt;&lt; var &lt;&lt; endl;
    cout &lt;&lt; "*p: "&lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; "a: "&lt;&lt; a &lt;&lt; endl;

    int * const p_const = &amp;a; //this is a pointer that has to be initialized when defined, because it cannot change after defining the thing that it is pointing to (address)

    const int * p_2 = &amp;a; //this is a pointer that cannot change the value that is under address its pointing to.

    const int * const p_3 = &amp;a; //this is a pointer that cannot change the value that is under address its pointing to and also it cant change the address

    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;

    int ordinary_var = 10;

    int *ordinary_p = &amp;ordinary_var;

    cout &lt;&lt; "ordinary_var: " &lt;&lt; ordinary_var &lt;&lt; endl; //integer value
    cout &lt;&lt; "&amp;ordinary_var: " &lt;&lt; &amp;ordinary_var &lt;&lt; endl; //integer value
    cout &lt;&lt; "ordinary_p: " &lt;&lt; ordinary_p &lt;&lt; endl; //address
    cout &lt;&lt; "*ordinary_p: " &lt;&lt; *ordinary_p &lt;&lt; endl; //integer value from pointed place (ordinary_var)
    cout &lt;&lt; "&amp;ordinary_p: " &lt;&lt; &amp;ordinary_p &lt;&lt; endl; //address of pointer itself

    int ** p_pointing_to_address_of_pointer = &amp;ordinary_p;

    cout &lt;&lt; "p_pointing_to_address_of_pointer: " &lt;&lt; p_pointing_to_address_of_pointer &lt;&lt; endl;

    return 0;
}

</code></pre></div></div>

<h1 id="c_str"><a href="https://www.geeksforgeeks.org/basic_string-c_str-function-in-c-stl/">c_str()</a></h1>
<ul>
  <li>The basic_string::c_str() is a builtin function in C++ which returns a pointer to an array that contains a null-terminated sequence of characters representing the current value of the basic_string object. This array includes the same sequence of characters that make up the value of the basic_string object plus an additional terminating null-character at the end.</li>
  <li>Retrun Value : The function returns a constant Null terminated pointer to the character array storage of the string.
```
// C++ code for illustration of
// basic_string::c_str function
#include &lt;bits/stdc++.h&gt;
#include <string>
using namespace std;</string></li>
</ul>

<p>int main()
{
    // declare a example string
    string s1 = â€œGeeksForGeeksâ€;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// check if the size of the string is same as the
// size of character pointer given by c_str
if (s1.size() == strlen(s1.c_str())) {
    cout &lt;&lt; "s1.size is equal to strlen(s1.c_str()) " &lt;&lt; endl;
}
else {
    cout &lt;&lt; "s1.size is not equal to strlen(s1.c_str())" &lt;&lt; endl;
}

// print the string
printf("%s \n", s1.c_str()); } ```
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
// C++ code for illustration of
// basic_string::c_str function
#include &lt;bits/stdc++.h&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
    // declare a example string
    string s1 = "Aditya";

    // print the characters of the string
    for (int i = 0; i &lt; s1.length(); i++) {
        cout &lt;&lt; "The " &lt;&lt; i + 1 &lt;&lt; "th character of string " &lt;&lt; s1
             &lt;&lt; " is " &lt;&lt; s1.c_str()[i] &lt;&lt; endl;
    }
}
</code></pre></div></div>

<h1 id="example-2">Example 2</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    string text = "this a test"; // t r a l a \0

/*
    for (int i = 0; i &lt; text.length(); i++)
    {
        cout &lt;&lt; text[i] &lt;&lt; endl;
    }
*/
  /*  char ch = text[0];

   // cout &lt;&lt; ch &lt;&lt; endl;

    char characters[] = "123asdfasdfasdf4";

    cout &lt;&lt; characters[0] &lt;&lt; endl;
    cout &lt;&lt; *(characters) &lt;&lt; endl;

    cout &lt;&lt; characters[1] &lt;&lt; endl;
    cout &lt;&lt; *(characters+1) &lt;&lt; endl;

    char *p = characters;

    cout &lt;&lt; p[0] &lt;&lt; endl;
    cout &lt;&lt; *(p) &lt;&lt; endl;

    cout &lt;&lt; p[1] &lt;&lt; endl;
    cout &lt;&lt; *(p+1) &lt;&lt; endl;
*/
    const char * text2 = text.c_str();

    cout &lt;&lt; text2 &lt;&lt; endl;

    char array[] = "here is a text";

    string test = array;

    cout &lt;&lt; test &lt;&lt; endl;


    const char * a = "this is a test 12512412";

    cout &lt;&lt; a[0] &lt;&lt; endl;

    char b[] = "this a test 124124";

    b[0] ='g';
    cout &lt;&lt; b &lt;&lt; endl;

    char * const dynamic_array = new char[50];
    dynamic_array[0] = 'k';
    dynamic_array[1] = '\0';
    //dynamic_array = "lalala";

    cout &lt;&lt; dynamic_array &lt;&lt; endl;

    delete [] dynamic_array;

    string array_of_string[5] = "this i a text that will be in all of the elements of strings";
    array_of_string[0] = "afsdf";
    cout &lt;&lt; array_of_string[0] &lt;&lt; endl;
    cout &lt;&lt; array_of_string[1] &lt;&lt; endl;
    cout &lt;&lt; array_of_string[2] &lt;&lt; endl;
    return 0;
}

</code></pre></div></div>

<h1 id="dynamic-memory"><a href="https://blockdmask.tistory.com/302">Dynamic memory</a></h1>
<ul>
  <li>newëŠ” <strong>í™ì— ë©”ëª¨ë¦¬í• ë‹¹</strong>ì„ í•´ì£¼ê³  <strong>ìƒì„±ìë¥¼ í˜¸ì¶œ</strong> í•´ì£¼ë©° <strong>í•´ë‹¹ íƒ€ì…ìœ¼ë¡œ ë³€í™˜</strong> ê¹Œì§€ í•´ì£¼ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.</li>
  <li>New ê°€ í•˜ëŠ” ì¼ì€
    <ul>
      <li>ë©”ëª¨ë¦¬ í• ë‹¹</li>
      <li>ìƒì„±ì í˜¸ì¶œ</li>
      <li>íƒ€ì… ë³€í™˜</li>
    </ul>
  </li>
  <li>Delete ê°€ í•˜ëŠ” ì¼ì€
    <ul>
      <li>ì†Œë©¸ì í˜¸ì¶œ</li>
      <li>ë©”ëª¨ë¦¬ í•´ì œ</li>
    </ul>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
using namespaec std;
class Position
{
  public:
     Position() // ìƒì„±ì
     {
       count &lt;&lt; 2) newì— ì˜í•´ ìƒì„±ì í˜¸ì¶œë¨ &lt;&lt; endl;
     }
     ~Position()
     {
       count &lt;&lt; 3) Deleteì— ì˜í•´ ì†Œë©¸ì í˜¸ì¶œ ë¨ &lt;&lt;endl;
     }
};

int main()
{
  Position* prt = new Position();
  count &lt;&lt; 1) new ë©”ëª¨ë¦¬ í• ë‹¹ ë : ìƒì„±ì ì½œ &lt;&lt; endl;
  delete(prt); // ë©”ëª¨ë¦¬ í•´ì œ
  return 0;
}
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;

using namespace std;
/* dynamic allocation of memory */

int main()
{
   // int var = 41240;
   /*

    int amount;

    cout &lt;&lt; "How many numbers would you like to store in an array? " &lt;&lt; endl;
    cin &gt;&gt; amount;

    int *p = new (nothrow) int[amount];

    if (p != NULL)
    {
        for (int i = 0; i &lt; amount; i++)
        {
            cout &lt;&lt; "Enter the " &lt;&lt; (i+1) &lt;&lt; " number: " &lt;&lt; endl;
            cin &gt;&gt; p[i];
        }

        for (int i = 0; i &lt; amount; i++)
        {
            cout &lt;&lt; "p [ " &lt;&lt; i &lt;&lt; " ] =  " &lt;&lt; p[i] &lt;&lt; endl;
        }
    }
    else
        cout &lt;&lt; "Not enough memory " &lt;&lt; endl;
*/

    {
        int *p = new int;

        cout &lt;&lt; p &lt;&lt; endl;

        delete p;

        p = new int;

        cout &lt;&lt; p &lt;&lt; endl;

        delete p;
    }


    //cout &lt;&lt; "var: " &lt;&lt; var &lt;&lt; endl;


    //delete []p;
    return 0;
}
</code></pre></div></div>

<h1 id="example-3">Example 3</h1>
<p><a href="https://postimg.cc/mcG5BVZN"><img src="https://i.postimg.cc/DzWkQYtD/array.jpg" width="500px" title="source: imgur.com" /><a></a></a></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;

using namespace std;

//void multiplyBy(int &amp;, int);
int *multiplyBy(int *, int);
void multiplyArrayBy(int *, int, int);

int main()
{

    int a = 10;

    int *b = multiplyBy(&amp;a, 5);

    *b = 999;
    cout &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; *b &lt;&lt; endl;


    int array[10];
    cout &lt;&lt; sizeof(array)/sizeof(array[0]) &lt;&lt; endl;
    // í•œ ì–´ë ˆì´ì— 4ë°”ì´íŠ¸ ì´ë‹ˆê¹Œ ì´ 40ë°”ì´íŠ¸ í•˜ë‚˜ë‹¹ 4ë°”ì´íŠ¸ë¥¼ ë‚˜ëˆ„ë©´ 10 ê°œ

    for (int i = 0; i &lt; sizeof(array)/sizeof(array[0]); i++)
    {
        array[i] = i;
     //   cout &lt;&lt; "array [" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; array[i] &lt;&lt; endl;
    }
    multiplyArrayBy(&amp;array[0], 5, sizeof(array)/sizeof(array[0])); // &amp;array[0] == array
    for (int i = 0; i &lt; sizeof(array)/sizeof(array[0]); i++)
    {
       cout &lt;&lt; "array [" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; array[i] &lt;&lt; endl;
    }

    return 0;
}
int *multiplyBy(int * var, int amount)
{
    //int * var = &amp;a;
    *var =  *var * amount;

    return var;
}
void multiplyArrayBy(int *array, int amount, int sizeOfArray)
{
    while(sizeOfArray--)
        array[sizeOfArray] *= amount;
}
</code></pre></div></div>
<h1 id="example-4">Example 4</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;time.h&gt;

using namespace std;
/* LOTTERY - pseudo-random numbers generator - drawing numbers */
void lottery(int, int);

int main()
{
//  srand(time(NULL)); //seeds

 //   int nr = rand() % 49 + 1; //[1, 49]

   // cout &lt;&lt; nr &lt;&lt; endl;



    lottery(49, 6);

    return 0;
}
void lottery(int total_balls, int balls_to_draw)
{
    if (total_balls &lt; balls_to_draw)
        return;

     srand(time(NULL)); //seeds

     int *balls = new int[balls_to_draw];

     for (int i = 0; i &lt; balls_to_draw; i++)
     {
         balls[i] = rand() % total_balls + 1;

         for (int j = 0; j &lt; i + 1; j++)
         {
            if(balls[i] == balls[j] &amp;&amp; i != j)
            {
                i--;
                break;
            }
            else if (j == i)
                cout &lt;&lt; balls[i] &lt;&lt; endl;
         }
     }

     delete[] balls;
}
</code></pre></div></div>

<h1 id="example-5">Example 5</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    int a[3];
    a[0] = 0;
    a[1] = 20;
    a[2] = 40;
    short int zm;
    int *const p = &amp;a[0];

    cout &lt;&lt; p &lt;&lt; endl;
    cout &lt;&lt; a &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &amp;a[0] &lt;&lt; endl;
    cout &lt;&lt; &amp;a[1] &lt;&lt; endl;
    cout &lt;&lt; &amp;a[2] &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; a + 1 &lt;&lt; endl;
    cout &lt;&lt; a + 2 &lt;&lt; endl;
    //this is kind of same as array a[0],a[1].a[2]

    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; *a &lt;&lt; endl;
    cout &lt;&lt; *(a + 1) &lt;&lt; endl;
    cout &lt;&lt; *(a + 2) &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; a[0] &lt;&lt; endl;
    cout &lt;&lt; a[1] &lt;&lt; endl;
    cout &lt;&lt; a[2] &lt;&lt; endl;

   // cout &lt;&lt; a++ &lt;&lt; endl; // a++  a = a + 1

    int * p2 = &amp;a[0];

    cout &lt;&lt; *p2 &lt;&lt; endl;  // 0
    cout &lt;&lt; ++*p2 &lt;&lt; endl; //1
    cout &lt;&lt; *++p2 &lt;&lt; endl; //20
    cout &lt;&lt; *p2++ &lt;&lt; endl; //20
    cout &lt;&lt; *p2 &lt;&lt; endl; //40
    return 0;
}

</code></pre></div></div>

<h1 id="static_cast">Static_cast&lt;&gt;</h1>
<ul>
  <li>explicit way in C++
```
#include <iostream></iostream></li>
</ul>

<p>using namespace std;
/* TYPE CASTING */</p>

<p>int main()
{
    double var = 5.6;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int a = 5;
int b = 7;
cout &lt;&lt; (double)a / b &lt;&lt; endl;

cout &lt;&lt; (int) var &lt;&lt; endl; //explict way C

int x = 444;
short y = x; //implicit way of casting

cout &lt;&lt; y &lt;&lt; endl;

cout &lt;&lt;  int(var) &lt;&lt; endl; //explict way C
cout &lt;&lt;  static_cast&lt;int&gt;(var) &lt;&lt; endl; //explict way in C++


char ch;

cin &gt;&gt; ch;

cout &lt;&lt; (int)ch &lt;&lt; endl;
return 0; } ``` # COSTì˜ í™œìš© - const í‚¤ì›Œë“œì™€ í•¨ê»˜ ì •ì˜í•œ ë³€ìˆ˜ì˜ ê°’ëŠ” ìˆ˜ì •ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ì¦‰ ìƒìˆ˜í™” ë˜ì–´ë²„ë¦¬ëŠ”ë°, í”„ë¡œê·¸ë˜ë°ì‹œì— ë°”ë€Œì–´ì„œëŠ” ì•ˆë ê°’ì´ ìˆì„ ê²½ìš° í™œìš©í•  ìˆ˜ ìˆë‹¤. ì½”ë“œê°€ ê¸¸ì–´ì§ˆ ê²½ìš° ì‹¤ìˆ˜ë¡œ ë³€ìˆ˜ì˜ ê°’ì´ ë°”ë€Œì–´ ì§€ëŠ”ê²ƒì„ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.
</code></pre></div></div>
:ET